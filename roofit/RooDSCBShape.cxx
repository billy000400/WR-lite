/**
 * @Author: Billy Li <billyli>
 * @Date:   04-26-2022
 * @Email:  li000400@umn.edu
 * @Last modified by:   billyli
 * @Last modified time: 04-26-2022
 */



/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooDSCBShape.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(RooDSCBShape);

 RooDSCBShape::RooDSCBShape(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsReal& _ mu,
                        RooAbsReal& _ sigma,
                        RooAbsReal& _ alphaL,
                        RooAbsReal& _ alphaR,
                        RooAbsReal& _ nL,
                        RooAbsReal& _ nR) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
    mu(" mu"," mu",this,_ mu),
    sigma(" sigma"," sigma",this,_ sigma),
    alphaL(" alphaL"," alphaL",this,_ alphaL),
    alphaR(" alphaR"," alphaR",this,_ alphaR),
    nL(" nL"," nL",this,_ nL),
    nR(" nR"," nR",this,_ nR)
 {
 }


 RooDSCBShape::RooDSCBShape(const RooDSCBShape& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
    mu(" mu",this,other. mu),
    sigma(" sigma",this,other. sigma),
    alphaL(" alphaL",this,other. alphaL),
    alphaR(" alphaR",this,other. alphaR),
    nL(" nL",this,other. nL),
    nR(" nR",this,other. nR)
 {
 }



 Double_t RooDSCBShape::evaluate() const
 {
   Double_t t = (x-mu)/sigma;

   Double_t absAlphaL = fabs((Double_t)alphaL);
   Double_t absAlphaR = fabs((Double_t)alphaR);

   if (t < -absAlphaL){

     Double_t exp_part = exp(-0.5*absAlphaL*absAlphaL);
     Double_t D = (nL-absAlphaL*absAlphaL-absAlphaL*t);
     Double_t arg = nL/D;

     return TMath::Power(arg, nL)*exp_part;

   } else if (t < absAlphaR) {

     return exp(-0.5*t*t);

   }
   else {
     // Double_t a =  TMath::Power(n/absAlpha,n)*exp(-0.5*absAlpha*absAlpha);
     // Double_t b= n/absAlpha - absAlpha;

     // return a/TMath::Power(b - t, n);

     Double_t exp_part = exp(-0.5*absAlphaR*absAlphaR);
     Double_t D = (nR-absAlphaR*absAlphaR+absAlphaR*t);
     Double_t arg = nR/D;

     return TMath::Power(arg, nR)*exp_part;
   }
 }
