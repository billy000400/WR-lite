/**
 * @Author: Billy Li <billyli>
 * @Date:   04-26-2022
 * @Email:  li000400@umn.edu
 * @Last modified by:   billyli
 * @Last modified time: 04-26-2022
 */



/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooDSCBShape.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(RooDSCBShape);

 RooDSCBShape::RooDSCBShape(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsReal& _mu,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alphaL,
                        RooAbsReal& _alphaR,
                        RooAbsReal& _nL,
                        RooAbsReal& _nR) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
    mu("mu","mu",this,_mu),
    sigma("sigma","sigma",this,_sigma),
    alphaL("alphaL","alphaL",this,_alphaL),
    alphaR("alphaR","alphaR",this,_alphaR),
    nL("nL","nL",this,_nL),
    nR("nR","nR",this,_nR)
 {
 }


 RooDSCBShape::RooDSCBShape(const RooDSCBShape& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
    mu("mu",this,other.mu),
    sigma("sigma",this,other.sigma),
    alphaL("alphaL",this,other.alphaL),
    alphaR("alphaR",this,other.alphaR),
    nL("nL",this,other.nL),
    nR("nR",this,other.nR)
 {
 }



 Double_t RooDSCBShape::evaluate() const
 {
   Double_t t = (x-mu)/sigma;

   Double_t absAlphaL = fabs((Double_t)alphaL);
   Double_t absAlphaR = fabs((Double_t)alphaR);

   if (t < -absAlphaL){

     Double_t exp_part = exp(-0.5*absAlphaL*absAlphaL);
     Double_t D = (nL-absAlphaL*absAlphaL-absAlphaL*t);
     Double_t arg = nL/D;

     return TMath::Power(arg, nL)*exp_part;

   } else if (t < absAlphaR) {

     return exp(-0.5*t*t);

   }
   else {
     // Double_t a =  TMath::Power(n/absAlpha,n)*exp(-0.5*absAlpha*absAlpha);
     // Double_t b= n/absAlpha - absAlpha;

     // return a/TMath::Power(b - t, n);

     Double_t exp_part = exp(-0.5*absAlphaR*absAlphaR);
     Double_t D = (nR-absAlphaR*absAlphaR+absAlphaR*t);
     Double_t arg = nR/D;

     return TMath::Power(arg, nR)*exp_part;
   }
 }
