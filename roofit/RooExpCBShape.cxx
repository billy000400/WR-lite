/**
 * @Author: Billy Li <billyli>
 * @Date:   04-26-2022
 * @Email:  li000400@umn.edu
 * @Last modified by:   billyli
 * @Last modified time: 04-26-2022
 */



/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooExpCBShape.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(RooExpCBShape);

 RooExpCBShape::RooExpCBShape(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsReal& _mu,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha,
                        RooAbsReal& _n,
                        RooAbsReal& _beta) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
   mu("mu","mu",this,_mu),
   sigma("sigma","sigma",this,_sigma),
   alpha("alpha","alpha",this,_alpha),
   n("n","n",this,_n),
   beta("beta","beta",this,_beta)
 {
 }


 RooExpCBShape::RooExpCBShape(const RooExpCBShape& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
   mu("mu",this,other.mu),
   sigma("sigma",this,other.sigma),
   alpha("alpha",this,other.alpha),
   n("n",this,other.n),
   beta("beta",this,other.beta)
 {
 }



 Double_t RooExpCBShape::evaluate() const
 {
   Double_t t = (x-mu)/sigma;

   Double_t absAlpha = fabs((Double_t)alpha);
   Double_t absBeta = fabs((Double_t)beta);
   Double_t result = 0;

   if (t < -absBeta){

     Double_t A = exp(0.5*absBeta*absBeta);
     result = A*exp(absBeta*t);

   } else if (t < absAlpha) {

     result = exp(-0.5*t*t);

   }
   else {
     // Double_t a =  TMath::Power(n/absAlpha,n)*exp(-0.5*absAlpha*absAlpha);
     // Double_t b= n/absAlpha - absAlpha;

     // return a/TMath::Power(b - t, n);

     Double_t exp_part = exp(-0.5*absAlpha*absAlpha);
     Double_t D = (n-absAlpha*absAlpha+absAlpha*t);
     Double_t arg = n/D;

     result = TMath::Power(arg, n)*exp_part;
   }

   result += 1e-38;
   return result
 }
